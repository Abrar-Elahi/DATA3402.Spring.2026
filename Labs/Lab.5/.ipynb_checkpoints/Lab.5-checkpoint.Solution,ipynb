{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Lab 5\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Matrix Representation: In this lab you will be creating a simple linear algebra system. In memory, we will represent matrices as nested python lists as we have done in lecture. In the exercises below, you are required to explicitly test every feature you implement, demonstrating it works.\n",
    "\n",
    "1. Create a `matrix` class with the following properties:\n",
    "    * It can be initialized in 2 ways:\n",
    "        1. with arguments `n` and `m`, the size of the matrix. A newly instanciated matrix will contain all zeros.\n",
    "        2. with a list of lists of values. Note that since we are using lists of lists to implement matrices, it is possible that not all rows have the same number of columns. Test explicitly that the matrix is properly specified.\n",
    "    * Matrix instances `M` can be indexed with `M[i][j]` and `M[i,j]`.\n",
    "    * Matrix assignment works in 2 ways:\n",
    "        1. If `M_1` and `M_2` are `matrix` instances `M_1=M_2` sets the values of `M_1` to those of `M_2`, if they are the same size. Error otherwise.\n",
    "        2. In example above `M_2` can be a list of lists of correct size.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Matrix:\n",
    "    def __init__(self,n=None,m=None,values=None):\n",
    "        if values is None:\n",
    "            if n is None or m is None:\n",
    "                raise ValueError(\"n or m value needed.\")\n",
    "            self.rows = n \n",
    "            self.cols = m \n",
    "            self.data = [[0 for el in range(m)] for el in range(n)]   \n",
    "        else:\n",
    "            if not isinstance(values,list):\n",
    "                raise TypeError(\"Values must be a list of lists.\")\n",
    "            if any(not isinstance(row,list) for row in values):\n",
    "                raise TypeError(\"Each row needs to be a list.\")\n",
    "\n",
    "            self.data = values\n",
    "            self.rows = len(values)\n",
    "            self.cols = max(len(row) for row in values) if values else 0\n",
    "#Two initializaitons are created which are either a 0 matrix or a matrix constructed from a list of lists when creating a new matrix\n",
    "    \n",
    "    def __getitem__(self,index):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            return self.data[i][j]\n",
    "        return self.data[index]\n",
    "# Allows to index the data using brackets to access it later on when testing the matrix\n",
    "    def __setitem__(self, index, value):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            self.data[i][j] = value\n",
    "        else:\n",
    "            self.data[index] = value\n",
    "# Allows me to change values inside the matrix using = \n",
    "    def assign(self, other):\n",
    "        if isinstance(other, Matrix):\n",
    "            if self.rows != other.rows or self.cols != other.cols:\n",
    "                raise ValueError(\"Sizes of matrices don't match.\")\n",
    "            self.data = [row[:] for row in other.data]\n",
    "            return\n",
    "        if isinstance(other,list):\n",
    "            if len(other) != self.rows:\n",
    "                raise ValueError(\"Count of rows don't match.\")\n",
    "            if max(len(row) for row in other) != self.cols:\n",
    "                raise ValueError(\"Count of columns don't match.\")\n",
    "            self.data = [row[:] for row in other]\n",
    "            return \n",
    "# Actually copies the matrix rather than using = through checking if another matrix or list matches each others dimensions\n",
    "        raise TypeError(\"Matrix or list of lists needed.\")\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Matrix({self.data})\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "A= Matrix([[0, 0, 0], [0, 0, 0]])\n",
      "B= Matrix([[1, 2], [3, 4, 5]])\n",
      "B[0][1]= 2\n",
      "B[1,2]= 5\n",
      "A after assigning (list)= Matrix([[9, 8, 7], [6, 5, 4]])\n",
      "C after assigning D= Matrix([[9], [8, 7, 6]])\n",
      "Error: Sizes of matrices don't match.\n"
     ]
    }
   ],
   "source": [
    "#Creates matrix using n and m, creatinga matrix that consists of all 0's\n",
    "A = Matrix(2,3)\n",
    "print(\"A=\",A)\n",
    "\n",
    "#Creates matrix using a list of lists\n",
    "B = Matrix(values=[[1,2],[3,4,5]])\n",
    "print(\"B=\",B)\n",
    "\n",
    "#Indexing matrix with M[i][j] and M[i,j].\n",
    "print(\"B[0][1]=\",B[0][1])\n",
    "print(\"B[1,2]=\", B[1,2])\n",
    "\n",
    "#Assigns list of lists to matrix\n",
    "A.assign([[9,8,7],[6,5,4]])\n",
    "print(\"A after assigning (list)=\", A)\n",
    "\n",
    "#Assigns one matrix to another matrix\n",
    "C = Matrix(values=[[1],[2,3,4]])\n",
    "D = Matrix(values=[[9],[8,7,6]])\n",
    "C.assign(D)\n",
    "print(\"C after assigning D=\", C)\n",
    "\n",
    "#Tests for errors\n",
    "E = Matrix(4,4)\n",
    "try:\n",
    "    C.assign(E)\n",
    "except Exception as e:\n",
    "    print(\"Error:\", e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2. Add the following methods:\n",
    "    * `shape()`: returns a tuple `(n,m)` of the shape of the matrix.\n",
    "    * `transpose()`: returns a new matrix instance which is the transpose of the matrix.\n",
    "    * `row(n)` and `column(n)`: that return the nth row or column of the matrix M as a new appropriately shaped matrix object.\n",
    "    * `to_list()`: which returns the matrix as a list of lists.\n",
    "    *  `block(n_0,n_1,m_0,m_1)` that returns a smaller matrix located at the n_0 to n_1 columns and m_0 to m_1 rows. \n",
    "    * (Extra credit) Modify `__getitem__` implemented above to support slicing.\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Matrix:\n",
    "    def __init__(self,n=None,m=None,values=None):\n",
    "        if values is None:\n",
    "            if n is None or m is None:\n",
    "                raise ValueError(\"n or m value needed.\")\n",
    "            self.rows = n \n",
    "            self.cols = m \n",
    "            self.data = [[0 for el in range(m)] for el in range(n)]\n",
    "        else:\n",
    "            if not isinstance(values,list):\n",
    "                raise TypeError(\"Values must be a list of lists.\")\n",
    "            if any(not isinstance(row,list) for row in values):\n",
    "                raise TypeError(\"Each row needs to be a list.\")\n",
    "\n",
    "            self.data = values\n",
    "            self.rows = len(values)\n",
    "            self.cols = max(len(row) for row in values) if values else 0\n",
    "\n",
    "    def __getitem__(self,index):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            return self.data[i][j]\n",
    "        return self.data[index]\n",
    "\n",
    "    def __setitem__(self, index, value):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            self.data[i][j] = value\n",
    "        else:\n",
    "            self.data[index] = value\n",
    "\n",
    "    def assign(self, other):\n",
    "        if isinstance(other, Matrix):\n",
    "            if self.rows != other.rows or self.cols != other.cols:\n",
    "                raise ValueError(\"Sizes of matrices don't match.\")\n",
    "            self.data = [row[:] for row in other.data]\n",
    "            return\n",
    "        if isinstance(other,list):\n",
    "            if len(other) != self.rows:\n",
    "                raise ValueError(\"Count of rows don't match.\")\n",
    "            if max(len(row) for row in other) != self.cols:\n",
    "                raise ValueError(\"Count of columns don't match.\")\n",
    "            self.data = [row[:] for row in other]\n",
    "            return \n",
    "\n",
    "        raise TypeError(\"Matrix or list of lists needed.\")\n",
    "\n",
    "    def shape(self):\n",
    "        return (self.rows,self.cols)\n",
    "#returns rows,columns\n",
    "    def transpose(self):\n",
    "        new_data = []\n",
    "        for j in range(self.cols):\n",
    "            col = []\n",
    "            for i in range(self.rows):\n",
    "                if j<len(self.data[i]):\n",
    "                    col.append(self.data[i][j])\n",
    "                else:\n",
    "                    col.append(0)\n",
    "            new_data.append(col)\n",
    "        return Matrix(values=new_data)\n",
    "#loops over the columns and rows and fills in the missing values and returns a new matrix where the rows become columns\n",
    "\n",
    "    def row(self, n):\n",
    "        return Matrix(values=[self.data[n][:]])\n",
    "# Returns nth row as new 1xm matrix\n",
    "\n",
    "    def column(self, n):\n",
    "        col = []\n",
    "        for i in range(self.rows):\n",
    "            if n < len(self.data[i]):\n",
    "                col.append([self.data[i][n]])\n",
    "            else:\n",
    "                col.append([0])\n",
    "        return Matrix(values=col)\n",
    "# Returns nth column as new nx1 Matrix, and handles any ragged rows by adding 0s\n",
    "\n",
    "    def to_list(self):\n",
    "        return [row[:] for row in self.data]\n",
    "#returns copy of matrix as a list of lists\n",
    "\n",
    "    def block(self, n0, n1, m0, m1):\n",
    "        new_vals = []\n",
    "        for i in range(n0, n1):\n",
    "            row = []\n",
    "            for j in range(m0, m1):\n",
    "                if j<len(self.data[i]):\n",
    "                    row.append(self.data[i][j])\n",
    "                else:\n",
    "                    row.append(0)\n",
    "            new_vals.append(row)\n",
    "        return Matrix(values=new_vals)\n",
    "#Returns submatrix using n1 and m1 values and the new vals variable\n",
    "\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Matrix({self.data})\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "shape(): (3, 3)\n",
      "Matrix([[1, 4, 6], [2, 5, 0], [3, 0, 0]])\n",
      "row(0): Matrix([[1, 2, 3]])\n",
      "row(1): Matrix([[4, 5]])\n",
      "column(0): Matrix([[1], [4], [6]])\n",
      "column(1): Matrix([[2], [5], [0]])\n",
      "column(2): Matrix([[3], [0], [0]])\n",
      "[[1, 2, 3], [4, 5], [6]]\n",
      "Matrix([[1, 2], [4, 5]])\n"
     ]
    }
   ],
   "source": [
    "#Testing shape\n",
    "M = Matrix(values=[[1,2,3],[4,5],[6]])\n",
    "print(\"shape():\", M.shape())\n",
    "\n",
    "#Testing Transpose\n",
    "print(M.transpose())\n",
    "\n",
    "#Testing row(n)\n",
    "print(\"row(0):\", M.row(0))\n",
    "print(\"row(1):\", M.row(1))\n",
    "\n",
    "#Testing column(n)\n",
    "print(\"column(0):\", M.column(0))\n",
    "print(\"column(1):\", M.column(1))\n",
    "print(\"column(2):\", M.column(2))\n",
    "\n",
    "#Testing to_list()\n",
    "print(M.to_list())\n",
    "#Testing block function\n",
    "\n",
    "print(M.block(0,2,0,2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3. Write functions that create special matrices (note these are standalone functions, not member functions of your `matrix` class):\n",
    "    * `constant(n,m,c)`: returns a `n` by `m` matrix filled with floats of value `c`.\n",
    "    * `zeros(n,m)` and `ones(n,m)`: return `n` by `m` matrices filled with floats of value `0` and `1`, respectively.\n",
    "    * `eye(n)`: returns the n by n identity matrix."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "def constant(n,m,c):\n",
    "    return Matrix(values=[[float(c) for el in range(m)] for el in range(n)])\n",
    "#Creates n*m matrix where each entry is a float value (c) and builds a list of lists\n",
    "def zeroes(n,m):\n",
    "     return Matrix(values=[[0.0 for el in range(m)] for el in range(n)])\n",
    "def ones(n,m):\n",
    "     return Matrix(values=[[1.0 for el in range(m)] for el in range(n)])\n",
    "def eye(n):\n",
    "    data = []\n",
    "    for i in range(n):\n",
    "        row = []\n",
    "        for j in range(n):\n",
    "            row.append(1.0 if i==j else 0.0)\n",
    "        data.append(row)\n",
    "    return Matrix(values=data)\n",
    "#Creates identity matrix with 1.0 float as diagonal and 0 everywhere else"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matrix([[5.0, 5.0, 5.0]])\n",
      "Matrix([[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]])\n",
      "Matrix([[1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]])\n",
      "Matrix([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n"
     ]
    }
   ],
   "source": [
    "print(constant(1,3,5))\n",
    "print(zeroes(2,4))\n",
    "print(ones(5,5))\n",
    "print(eye(3))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4. Add the following member functions to your class. Make sure to appropriately test the dimensions of the matrices to make sure the operations are correct.\n",
    "    * `M.scalarmul(c)`: a matrix that is scalar product $cM$, where every element of $M$ is multiplied by $c$.\n",
    "    * `M.add(N)`: adds two matrices $M$ and $N$. Donâ€™t forget to test that the sizes of the matrices are compatible for this and all other operations.\n",
    "    * `M.sub(N)`: subtracts two matrices $M$ and $N$.\n",
    "    * `M.mat_mult(N)`: returns a matrix that is the matrix product of two matrices $M$ and $N$.\n",
    "    * `M.element_mult(N)`: returns a matrix that is the element-wise product of two matrices $M$ and $N$.\n",
    "    * `M.equals(N)`: returns true/false if $M==N$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    def scalarmul(self,c):\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(len(self.data[i])):\n",
    "                row.append(self.data[i][j]*c)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "# Returns new matrix after appending original list of data by multiplying by the scalar c\n",
    "\n",
    "    def add(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Matrix sizes don't match for addition.\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a+b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Checks if matrices have same dimensions for addition and takes the preexisting value in the matrix and adds it to the new value\n",
    "    def sub(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Matrix sizes don't match for subtraction.\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a-b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Coded the same as matrix addition but just changed value to subtraction\n",
    "    def mat_mult(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.cols != N.rows:\n",
    "            raise ValueError(\"Wrong dimensions for matrix multiplication\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(N.cols):\n",
    "                total = 0\n",
    "                for k in range(self.cols):\n",
    "                    a = self.data[i][k] if k<len(self.data[i]) else 0\n",
    "                    b = N.data[k][j] if j<len(N.data[k]) else 0\n",
    "                    total += a*b\n",
    "                row.append(total)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Takes dot product from row of first matrix and columns of second matrix and calculates product to make new matrix\n",
    "    def elem_mult(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Wrong dimensions for element wise multiplication\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a*b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Checks that both matrices have same # of rows and cols and loops through each position and multiplies them\n",
    "    def equals(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            return False\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            return False\n",
    "            \n",
    "        for i in range(self.rows):\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                if a != b:\n",
    "                    return False\n",
    "        return True\n",
    "#Checks that matrix shapes match and compares each pair"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Matrix:\n",
    "    def __init__(self,n=None,m=None,values=None):\n",
    "        if values is None:\n",
    "            if n is None or m is None:\n",
    "                raise ValueError(\"n or m value needed.\")\n",
    "            self.rows = n \n",
    "            self.cols = m \n",
    "            self.data = [[0 for el in range(m)] for el in range(n)]\n",
    "        else:\n",
    "            if not isinstance(values,list):\n",
    "                raise TypeError(\"Values must be a list of lists.\")\n",
    "            if any(not isinstance(row,list) for row in values):\n",
    "                raise TypeError(\"Each row needs to be a list.\")\n",
    "\n",
    "            self.data = values\n",
    "            self.rows = len(values)\n",
    "            self.cols = max(len(row) for row in values) if values else 0\n",
    "\n",
    "    def __getitem__(self,index):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            return self.data[i][j]\n",
    "        return self.data[index]\n",
    "\n",
    "    def __setitem__(self,index,value):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            self.data[i][j] = value\n",
    "        else:\n",
    "            self.data[index] = value\n",
    "\n",
    "    def assign(self,other):\n",
    "        if isinstance(other, Matrix):\n",
    "            if self.rows != other.rows or self.cols != other.cols:\n",
    "                raise ValueError(\"Sizes of matrices don't match.\")\n",
    "            self.data = [row[:] for row in other.data]\n",
    "            return\n",
    "        if isinstance(other,list):\n",
    "            if len(other) != self.rows:\n",
    "                raise ValueError(\"Count of rows don't match.\")\n",
    "            if max(len(row) for row in other) != self.cols:\n",
    "                raise ValueError(\"Count of columns don't match.\")\n",
    "            self.data = [row[:] for row in other]\n",
    "            return \n",
    "\n",
    "        raise TypeError(\"Matrix or list of lists needed.\")\n",
    "\n",
    "    def shape(self):\n",
    "        return (self.rows,self.cols)\n",
    "#returns rows,columns\n",
    "    def transpose(self):\n",
    "        new_data = []\n",
    "        for j in range(self.cols):\n",
    "            col = []\n",
    "            for i in range(self.rows):\n",
    "                if j<len(self.data[i]):\n",
    "                    col.append(self.data[i][j])\n",
    "                else:\n",
    "                    col.append(0)\n",
    "            new_data.append(col)\n",
    "        return Matrix(values=new_data)\n",
    "#loops over the columns and rows and fills in the missing values and returns a new matrix where the rows become columns\n",
    "\n",
    "    def row(self,n):\n",
    "        return Matrix(values=[self.data[n][:]])\n",
    "# Returns nth row as new 1xm matrix\n",
    "\n",
    "    def column(self,n):\n",
    "        col = []\n",
    "        for i in range(self.rows):\n",
    "            if n < len(self.data[i]):\n",
    "                col.append([self.data[i][n]])\n",
    "            else:\n",
    "                col.append([0])\n",
    "        return Matrix(values=col)\n",
    "# Returns nth column as new nx1 Matrix, and handles any ragged rows by adding 0s\n",
    "\n",
    "    def to_list(self):\n",
    "        return [row[:] for row in self.data]\n",
    "#returns copy of matrix as a list of lists\n",
    "\n",
    "    def block(self, n0, n1, m0, m1):\n",
    "        new_vals = []\n",
    "        for i in range(n0, n1):\n",
    "            row = []\n",
    "            for j in range(m0, m1):\n",
    "                if j<len(self.data[i]):\n",
    "                    row.append(self.data[i][j])\n",
    "                else:\n",
    "                    row.append(0)\n",
    "            new_vals.append(row)\n",
    "        return Matrix(values=new_vals)\n",
    "#Returns submatrix using n1 and m1 values and the new vals variable\n",
    "\n",
    "    def scalarmul(self,c):\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(len(self.data[i])):\n",
    "                row.append(self.data[i][j]*c)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "# Returns new matrix after appending original list of data by multiplying by the scalar c\n",
    "\n",
    "    def add(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Matrix sizes don't match for addition.\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a+b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Checks if matrices have same dimensions for addition and takes the preexisting value in the matrix and adds it to the new value\n",
    "    def sub(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Matrix sizes don't match for subtraction.\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a-b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Coded the same as matrix addition but just changed value to subtraction\n",
    "    def mat_mult(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.cols != N.rows:\n",
    "            raise ValueError(\"Wrong dimensions for matrix multiplication\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(N.cols):\n",
    "                total = 0\n",
    "                for k in range(self.cols):\n",
    "                    a = self.data[i][k] if k<len(self.data[i]) else 0\n",
    "                    b = N.data[k][j] if j<len(N.data[k]) else 0\n",
    "                    total += a*b\n",
    "                row.append(total)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Takes dot product from row of first matrix and columns of second matrix and calculates product to make new matrix\n",
    "    def elem_mult(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Wrong dimensions for element wise multiplication\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a*b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Checks that both matrices have same # of rows and cols and loops through each position and multiplies them\n",
    "    def equals(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            return False\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            return False\n",
    "            \n",
    "        for i in range(self.rows):\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                if a != b:\n",
    "                    return False\n",
    "        return True\n",
    "#Checks that matrix shapes match and compares each pair\n",
    "    def __repr__(self):\n",
    "        return f\"Matrix({self.data})\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matrix([[2, 4, 6], [8, 10, 12]])\n",
      "Matrix([[8, 10, 12], [5, 7, 9]])\n",
      "Matrix([[-6, -6, -6], [3, 3, 3]])\n",
      "Matrix([[22, 28], [49, 64]])\n",
      "Matrix([[7, 16, 27], [4, 10, 18]])\n",
      "True\n",
      "False\n"
     ]
    }
   ],
   "source": [
    "A = Matrix(values=[[1,2,3],[4,5,6]])\n",
    "B = Matrix(values=[[7,8,9],[1,2,3]])\n",
    "C = Matrix(values=[[1,2],[3,4],[5,6]])\n",
    "#Scalar mult\n",
    "print(A.scalarmul(2))\n",
    "\n",
    "#Matrix addition\n",
    "print(A.add(B))\n",
    "\n",
    "#Matrix subtraction\n",
    "print(A.sub(B))\n",
    "\n",
    "#Multiplication\n",
    "print(A.mat_mult(C))\n",
    "\n",
    "#Elementwise multiplication\n",
    "print(A.elem_mult(B))\n",
    "\n",
    "#Equals\n",
    "print(A.equals(A))\n",
    "print(A.equals(B))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "5. Overload python operators to appropriately use your functions in 4 and allow expressions like:\n",
    "    * 2*M\n",
    "    * M*2\n",
    "    * M+N\n",
    "    * M-N\n",
    "    * M*N\n",
    "    * M==N\n",
    "    * M=N\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def __rmul__(self, c):\n",
    "        return self.scalarmul(c)\n",
    "\n",
    "    def __mul__(self, other):\n",
    "        if isinstance(other, (int, float)):\n",
    "            return self.scalarmul(other)\n",
    "        if isinstance(other, Matrix):\n",
    "            return self.mat_mult(other)\n",
    "        raise TypeError(\"Invalid opperand\") #If right operand is a # then uses scalar mult, if it is a matrix uses matrix mult\n",
    "\n",
    "    def __add__(self, other):\n",
    "        if not isinstance(other, Matrix):\n",
    "            raise TypeError(\"Can only add Matrix to Matrix\")\n",
    "        return self.add(other) #Calls add function, checks if operand is a matrix \n",
    "\n",
    "    def __sub__(self, other):\n",
    "        if not isinstance(other, Matrix):\n",
    "            raise TypeError(\"Can only subtract Matrix from Matrix\")\n",
    "        return self.sub(other)\n",
    "        \n",
    "    def __eq__(self, other):\n",
    "        if not isinstance(other, Matrix):\n",
    "            return False\n",
    "        return self.equals(other) #Calls equals method and returns true if every element matches\n",
    "#Cannot overload M=N since = is not an operator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Matrix:\n",
    "    def __init__(self,n=None,m=None,values=None):\n",
    "        if values is None:\n",
    "            if n is None or m is None:\n",
    "                raise ValueError(\"n or m value needed.\")\n",
    "            self.rows = n \n",
    "            self.cols = m \n",
    "            self.data = [[0 for el in range(m)] for el in range(n)]\n",
    "        else:\n",
    "            if not isinstance(values,list):\n",
    "                raise TypeError(\"Values must be a list of lists.\")\n",
    "            if any(not isinstance(row,list) for row in values):\n",
    "                raise TypeError(\"Each row needs to be a list.\")\n",
    "\n",
    "            self.data = values\n",
    "            self.rows = len(values)\n",
    "            self.cols = max(len(row) for row in values) if values else 0\n",
    "\n",
    "    def __getitem__(self,index):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            return self.data[i][j]\n",
    "        return self.data[index]\n",
    "\n",
    "    def __setitem__(self,index,value):\n",
    "        if isinstance(index,tuple):\n",
    "            i,j = index\n",
    "            self.data[i][j] = value\n",
    "        else:\n",
    "            self.data[index] = value\n",
    "\n",
    "    def assign(self,other):\n",
    "        if isinstance(other, Matrix):\n",
    "            if self.rows != other.rows or self.cols != other.cols:\n",
    "                raise ValueError(\"Sizes of matrices don't match.\")\n",
    "            self.data = [row[:] for row in other.data]\n",
    "            return\n",
    "        if isinstance(other,list):\n",
    "            if len(other) != self.rows:\n",
    "                raise ValueError(\"Count of rows don't match.\")\n",
    "            if max(len(row) for row in other) != self.cols:\n",
    "                raise ValueError(\"Count of columns don't match.\")\n",
    "            self.data = [row[:] for row in other]\n",
    "            return \n",
    "\n",
    "        raise TypeError(\"Matrix or list of lists needed.\")\n",
    "\n",
    "    def shape(self):\n",
    "        return (self.rows,self.cols)\n",
    "#returns rows,columns\n",
    "    def transpose(self):\n",
    "        new_data = []\n",
    "        for j in range(self.cols):\n",
    "            col = []\n",
    "            for i in range(self.rows):\n",
    "                if j<len(self.data[i]):\n",
    "                    col.append(self.data[i][j])\n",
    "                else:\n",
    "                    col.append(0)\n",
    "            new_data.append(col)\n",
    "        return Matrix(values=new_data)\n",
    "#loops over the columns and rows and fills in the missing values and returns a new matrix where the rows become columns\n",
    "\n",
    "    def row(self,n):\n",
    "        return Matrix(values=[self.data[n][:]])\n",
    "# Returns nth row as new 1xm matrix\n",
    "\n",
    "    def column(self,n):\n",
    "        col = []\n",
    "        for i in range(self.rows):\n",
    "            if n < len(self.data[i]):\n",
    "                col.append([self.data[i][n]])\n",
    "            else:\n",
    "                col.append([0])\n",
    "        return Matrix(values=col)\n",
    "# Returns nth column as new nx1 Matrix, and handles any ragged rows by adding 0s\n",
    "\n",
    "    def to_list(self):\n",
    "        return [row[:] for row in self.data]\n",
    "#returns copy of matrix as a list of lists\n",
    "\n",
    "    def block(self, n0, n1, m0, m1):\n",
    "        new_vals = []\n",
    "        for i in range(n0, n1):\n",
    "            row = []\n",
    "            for j in range(m0, m1):\n",
    "                if j<len(self.data[i]):\n",
    "                    row.append(self.data[i][j])\n",
    "                else:\n",
    "                    row.append(0)\n",
    "            new_vals.append(row)\n",
    "        return Matrix(values=new_vals)\n",
    "#Returns submatrix using n1 and m1 values and the new vals variable\n",
    "\n",
    "    def scalarmul(self,c):\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(len(self.data[i])):\n",
    "                row.append(self.data[i][j]*c)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "# Returns new matrix after appending original list of data by multiplying by the scalar c\n",
    "\n",
    "    def add(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Matrix sizes don't match for addition.\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a+b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Checks if matrices have same dimensions for addition and takes the preexisting value in the matrix and adds it to the new value\n",
    "    def sub(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Matrix sizes don't match for subtraction.\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a-b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Coded the same as matrix addition but just changed value to subtraction\n",
    "    def mat_mult(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.cols != N.rows:\n",
    "            raise ValueError(\"Wrong dimensions for matrix multiplication\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(N.cols):\n",
    "                total = 0\n",
    "                for k in range(self.cols):\n",
    "                    a = self.data[i][k] if k<len(self.data[i]) else 0\n",
    "                    b = N.data[k][j] if j<len(N.data[k]) else 0\n",
    "                    total += a*b\n",
    "                row.append(total)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Takes dot product from row of first matrix and columns of second matrix and calculates product to make new matrix\n",
    "    def elem_mult(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            raise TypeError(\"Must input matrix.\")\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            raise ValueError(\"Wrong dimensions for element wise multiplication\")\n",
    "\n",
    "        new_data = []\n",
    "        for i in range(self.rows):\n",
    "            row = []\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                row.append(a*b)\n",
    "            new_data.append(row)\n",
    "        return Matrix(values=new_data)\n",
    "#Checks that both matrices have same # of rows and cols and loops through each position and multiplies them\n",
    "    def equals(self,N):\n",
    "        if not isinstance(N,Matrix):\n",
    "            return False\n",
    "        if self.rows != N.rows or self.cols != N.cols:\n",
    "            return False\n",
    "            \n",
    "        for i in range(self.rows):\n",
    "            for j in range(self.cols):\n",
    "                a = self.data[i][j] if j<len(self.data[i]) else 0\n",
    "                b = N.data[i][j] if j<len(N.data[i]) else 0\n",
    "                if a != b:\n",
    "                    return False\n",
    "        return True\n",
    "        \n",
    "    def __rmul__(self, c):\n",
    "        return self.scalarmul(c)\n",
    "\n",
    "    def __mul__(self, other):\n",
    "        if isinstance(other, (int, float)):\n",
    "            return self.scalarmul(other)\n",
    "        if isinstance(other, Matrix):\n",
    "            return self.mat_mult(other)\n",
    "        raise TypeError(\"Wrong operand used\")\n",
    "\n",
    "    def __add__(self, other):\n",
    "        if not isinstance(other, Matrix):\n",
    "            raise TypeError(\"Can only add Matrix to Matrix\")\n",
    "        return self.add(other)\n",
    "\n",
    "    def __sub__(self, other):\n",
    "        if not isinstance(other, Matrix):\n",
    "            raise TypeError(\"Can only subtract Matrix from Matrix\")\n",
    "        return self.sub(other)\n",
    "        \n",
    "    def __eq__(self, other):\n",
    "        if not isinstance(other, Matrix):\n",
    "            return False\n",
    "        return self.equals(other)\n",
    "\n",
    "\n",
    "\n",
    "#Checks that matrix shapes match and compares each pair\n",
    "    def __repr__(self):\n",
    "        return f\"Matrix({self.data})\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matrix([[2, 4], [6, 8]])\n",
      "Matrix([[2, 4], [6, 8]])\n",
      "Matrix([[6, 8], [10, 12]])\n",
      "Matrix([[-4, -4], [-4, -4]])\n",
      "Matrix([[19, 22], [43, 50]])\n",
      "True\n",
      "False\n"
     ]
    }
   ],
   "source": [
    "A = Matrix(values=[[1,2],[3,4]])\n",
    "B = Matrix(values=[[5,6],[7,8]])\n",
    "#Testing overloading operators\n",
    "print(2*A)          \n",
    "print(A*2)    \n",
    "print(A+B)          \n",
    "print(A-B)          \n",
    "print(A*B)          \n",
    "print(A == A)       \n",
    "print(A == B)       "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "6. Demonstrate the basic properties of matrices with your matrix class by creating two 2 by 2 example matrices using your Matrix class and illustrating the following:\n",
    "\n",
    "$$\n",
    "(AB)C=A(BC)\n",
    "$$\n",
    "$$\n",
    "A(B+C)=AB+AC\n",
    "$$\n",
    "$$\n",
    "AB\\neq BA\n",
    "$$\n",
    "$$\n",
    "AI=A\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Associative\n",
      "Left Side: Matrix([[193, 44], [437, 100]])\n",
      "Right Side: Matrix([[193, 44], [437, 100]])\n",
      "Check: True\n",
      "\n",
      "Distributive\n",
      "Left Side: Matrix([[30, 26], [74, 58]])\n",
      "Right Side: Matrix([[30, 26], [74, 58]])\n",
      "Check: True\n",
      "\n",
      "Non-Commutative\n",
      "AB: Matrix([[19, 22], [43, 50]])\n",
      "BA: Matrix([[23, 34], [31, 46]])\n",
      "AB != BA: True\n",
      "\n",
      "Identity\n",
      "AI: Matrix([[1, 2], [3, 4]])\n",
      "A: Matrix([[1, 2], [3, 4]])\n",
      "Check: True\n"
     ]
    }
   ],
   "source": [
    "A = Matrix(values=[[1, 2], [3, 4]])\n",
    "B = Matrix(values=[[5, 6], [7, 8]])\n",
    "C = Matrix(values=[[9, 0], [1, 2]])\n",
    "I = Matrix(values=[[1, 0], [0, 1]]) # Identity Matrix\n",
    "\n",
    "print(\"Associative\")\n",
    "left_a = (A * B) * C\n",
    "right_a = A * (B * C)\n",
    "print(f\"Left Side: {left_a}\")\n",
    "print(f\"Right Side: {right_a}\")\n",
    "print(f\"Check: {left_a == right_a}\")\n",
    "\n",
    "print(\"\\nDistributive\")\n",
    "left_d = A * (B + C)\n",
    "right_d = (A * B) + (A * C)\n",
    "print(f\"Left Side: {left_d}\")\n",
    "print(f\"Right Side: {right_d}\")\n",
    "print(f\"Check: {left_d == right_d}\")\n",
    "\n",
    "print(\"\\nNon-Commutative\")\n",
    "ab = A*B\n",
    "ba = B*A\n",
    "print(f\"AB: {ab}\")\n",
    "print(f\"BA: {ba}\")\n",
    "print(f\"AB != BA: {ab != ba}\")\n",
    "\n",
    "print(\"\\nIdentity\")\n",
    "ai = A * I\n",
    "print(f\"AI: {ai}\")\n",
    "print(f\"A: {A}\")\n",
    "print(f\"Check: {ai == A}\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
